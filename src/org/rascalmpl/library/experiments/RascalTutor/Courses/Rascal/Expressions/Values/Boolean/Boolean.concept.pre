concept("Boolean",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Boolean/Boolean.concept|,[],[],{"Language","Beginner"},{"Patterns"},""," \<code\>true\</code\>, \<code\>false\</code\>\n"," \<code\>bool\</code\>\n","",{"true","bool","false"}," The Booleans are represented by the type \<code\>bool\</code\> which has two values: \<code\>true\</code\> and \<code\>false\</code\>.\n \<br/\>\n\<br/\>\n\n The Boolean operators (to be more precise: operators with a value of type Boolean as result) have \<i\>short-circuit\</i\> semantics. \n This means that the operands are evaluated until the outcome of the operator is known.\n \<br/\>\n\<br/\>\n\n Most operator are self-explanatory except the match (:=) and no match (!:=) operators that are also the main reason to treat Boolean operator expressions separately. Although we describe patterns in full detail in the section called \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>, a preview is useful here. A pattern can\n  \<ul\>\<li\> match (or not match) any arbitrary value (that we will call the \<i\>subject value\</i\>);\</li\>\n\<li\> during the match variables may be bound to subvalues of the subject value.\</li\>\n\</ul\> The \<i\>match\</i\> operator\n \<pre class=\"listing\"\>\<i\>Pat\</i\> := \<i\>Exp\</i\>\n\</pre\> is evaluated as follows:\n  \<ul\>\<li\> \<code\>\<i\>Exp\</i\>\</code\> is evaluated, the result is a subject value;\</li\>\n\<li\> the subject value is matched against the pattern \<code\>\<i\>Pat\</i\>\</code\>;\</li\>\n\<li\> if the match succeeds, any variables in the pattern are bound to subvalues of the subject value and the match expression yields \<code\>true\</code\>;\</li\>\n\<li\> if the match fails, no variables are bound and the match expression yields \<code\>false\</code\>.\</li\>\n\</ul\> This looks and \<i\>is\</i\> nice and dandy, so why all this fuss about Boolean operators?\n The catch is that--as we will see in \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>--a match need not be unique. This means that there may be more than one way of matching the subject value resulting in different variable bindings. \n \<br/\>\n\<br/\>\n\n This behaviour is applicable in the context of all Rascal constructs where a pattern match determines the flow of control of the program, in particular:\n  \<ul\>\<li\> Boolean expressions: when a pattern match fails that is part of a Boolean expression, further solutions are tried in order to try to make the Boolean expression true.\</li\>\n\<li\> Tests in for, while, do statements.\</li\>\n\<li\> Tests in one and all expressions.\</li\>\n\<li\> Tests and enumerators in comprehensions.\</li\>\n\<li\> Pattern matches in visit expression and switch statement.\</li\>\n\<li\> Pattern matches during rewriting.\</li\>\n\</ul\>"," Consider the following match of a list\n \<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4]\n\</pre\> By definition \<code\>list[int] L\</code\> and \<code\>list[int] M\</code\> match list elements that are part of the enclosing list in which they occur. If they should match a nested list each should be enclosed in list brackets.\n \<br/\>\n\<br/\>\n\n There are two solutions for the above match:\n  \<ul\>\<li\> \<code\>L\</code\> = \<code\>[]\</code\> and \<code\>M\</code\> =\<code\> [2, 3, 2, 4]\</code\>; and\</li\>\n\<li\> \<code\>L\</code\> = \<code\>[2,3]\</code\> and \<code\>M\</code\> =\<code\> [4]\</code\>.\</li\>\n\</ul\> Depending on the context, only the first solution of a match expression is used, respectively all solutions are used.\n If a match expression occurs in a larger Boolean expression, a subsequent subexpression may yield false and -- depending on the actual operator -- evaluation backtracks to a previously evaluated match operator to try a next solution. Let\'\\s illustrate this by extending the above example:\n  \<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4] &amp;&amp; size(L) \> 0\n\</pre\> where we are looking for a solution in which L has a non-empty list as value. Evaluation proceeds as follows:\n  \<ul\>\<li\> The left argument of the \<code\>&amp;&amp;\</code\> operator is evaluated: the match expression is evaluated resulting in the bindings \<code\>L = []\</code\> and \<code\>M = [2, 3, 2, 4]\</code\>;\</li\>\n\<li\> The right argument of the \<code\>&amp;&amp;\</code\> operator is evaluated: \<code\>size(L) \> 0\</code\> yields \<code\>false\</code\>;\</li\>\n\<li\> Backtrack to the left argument of the \<code\>&amp;&amp;\</code\> operator to check for more solutions: indeed there are more solutions resulting in the bindings \<code\>L = [2,3]\</code\> and \<code\>M = [4]\</code\>;\</li\>\n\<li\> Proceed to the right operator of \<code\>&amp;&amp;\</code\>: this time \<code\>size(L) \> 0\</code\> yields \<code\>true\</code\>;\</li\>\n\<li\> The result of evaluating the complete expression is \<code\>true\</code\>.\</li\>\n\</ul\>","","",[])