concept("IntroDatatypes",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/IntroDatatypes/IntroDatatypes.concept|,[],[],{"Beginner"},{"List","Real","Integer","Relation","Map","DateTime","Number","Tuple","Boolean","Location","Node","Set","String","Declarations/AlgebraicDataType"},"","","","",{}," Rascal provides a rich set of datatypes:\n \<ul\>\<li\> \<a href=\"/show?concept=Boolean\"\>Boolean\</a\> (\<code\>bool\</code\>).\</li\>\n\<li\> Infinite precision \<a href=\"/show?concept=Integer\"\>Integer\</a\> (\<code\>int\</code\>), \<a href=\"/show?concept=Real\"\>Real\</a\> (\<code\>real\</code\>), and \<a href=\"/show?concept=Number\"\>Number\</a\> (\<code\>num\</code\>).\</li\>\n\<li\> \<a href=\"/show?concept=String\"\>String\</a\>s (\<code\>str\</code\>) that can act as templates with embedded expressions and statements. \</li\>\n\<li\> Source code \<a href=\"/show?concept=Location\"\>Location\</a\>s (\<code\>loc\</code\>) based on an extension of Universal Resource Identifiers (URI) that allow precise description of text areas in local and remote files.\</li\>\n\<li\> Date and time values (\<a href=\"/show?concept=DateTime\"\>DateTime\</a\>, \<code\>datetime\</code\>).\</li\>\n\<li\> \<a href=\"/show?concept=List\"\>List\</a\> (\<code\>list\</code\>).\</li\>\n\<li\> \<a href=\"/show?concept=Tuple\"\>Tuple\</a\> (\<code\>tuple\</code\>).\</li\>\n\<li\> \<a href=\"/show?concept=Set\"\>Set\</a\> (\<code\>set\</code\>).\</li\>\n\<li\> \<a href=\"/show?concept=Map\"\>Map\</a\> (\<code\>map\</code\>) \</li\>\n\<li\> \<a href=\"/show?concept=Relation\"\>Relation\</a\> (\<code\>rel\</code\>). \</li\>\n\<li\> Untyped tree structures (\<a href=\"/show?concept=Node\"\>Node\</a\>, \<code\>node\</code\>).  \</li\>\n\<li\> User-defined algebraic datatypes (\<a href=\"/show?concept=Declarations/AlgebraicDataType\"\>Declarations/AlgebraicDataType\</a\>, \<code\>data\</code\>) allow the introduction of problem-specific types and are a subtype of node.    This makes it possible to have typed\n   and untyped views on the same data. \n   A special case are syntax trees that are the result of parsing source files are represented \n   as datatypes (\<code\>Tree\</code\>).\n\</li\>\n\</ul\> There is a wealth of built-in operators and library functions available on the standard datatypes. \n \<br/\>\n\<br/\>\n\n These builtin datatypes are closely related to each other:\n  \<ul\>\<li\> In a list all elements have the same static type and the order of elements matters. A list may contain the same value more than once.\</li\>\n\<li\> In a set all elements have the same static type and the order of elements does not matter.   A set contains an element only once. In other words, duplicate elements are eliminated \n   and no matter how many times an element is added to a set, it will occur in it only once.\n\</li\>\n\<li\> In a tuple alle elements (may) have a different static type. Each element of a tuple may have a label that can be used to select that     element of the tuple.\n\</li\>\n\<li\> A relation is a set of tuples which all have the same static tuple type.\</li\>\n\<li\> A map is an associative table of (key, value) pairs. Key and value (may) have different static    type and a key can only be associated with a value once.\n\</li\>\n\</ul\>"," Here are some examples of the built-in data types:\n \<table\>\n \<colgroup\>\n \<col align=\"left\" span=\"2\"\>\n \<thead\>\n \<tr\>\<th\>\<i\>Type\</i\>\</th\> \<th\>\<i\>Examples\</i\>\</th\>\</tr\>\n \<tbody\>\n \<tr\>\<td\>\<code\>bool\</code\>\</td\>\t                   \<td\>\<code\>true\</code\>, \<code\>false\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>int\</code\>\</td\>\t                   \<td\>\<code\>11, 101, 1-11, 1123456789\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>real\</code\>\</td\>\t                   \<td\>\<code\>1.01, 11.0232e201, 1-25.5\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>str\</code\>\</td\>\t                   \<td\>\<code\>\"abc\"\</code\>, \<code\>\"first\\nnext\"\</code\>, \<code\>\"result: &lt;X\>\"\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>loc\</code\>\</td\>\t                    \<td\>\<code\>|file:///etc/passwd|\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>dateTime\</code\>\</td\>               \t\<td\>\<code\>$2101-09-05T07:16:19.714+0200\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>tuple[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\</code\>\t\t\t\</td\>\<td\>\<code\>&lt;1,2\>\</code\>, \<code\>&lt;\"john\", 43, true\>\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>list[\<i\>T\</i\>]\</code\>\</td\>\t            \<td\>\<code\>[]\</code\>, \<code\>[1]\</code\>, \<code\>[1,2,3]\</code\>, \<code\>[true, 2, \"abc\"]\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>set[\<i\>T\</i\>]\</code\>\</td\>\t            \t\<td\>\<code\>{}\</code\>, \<code\>{1,2,3,5,7}\</code\>, \<code\>{\"john\", 4.0}\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>rel[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\</code\>\</td\>    \t\<td\>\<code\>{&lt;1,2\>,&lt;2,3\>,&lt;1,3\>}\</code\>, \<code\>{&lt;1,10,100\>, &lt;2,20,200\>}\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>map[\<i\>T\</i\>, \<i\>U\</i\>]\</code\>\</td\>\t    \t\<td\>\<code\>()\</code\>, \<code\>(1:true, 2:false)\</code\>, \<code\>(\"a\":1, \"b\":2)\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>node\</code\>\</td\>\t                    \<td\>\<code\>f()\</code\>, \<code\>add(x,y)\</code\>, \<code\>g(\"abc\", [2,3,4])\</code\>\</td\>\</tr\>\n \</table\>\n \<br\>\n A fragment of the datatype that defines the abstract syntax for statements (assignment, if, while) in a programming language would look as follows:\n  \<pre class=\"listing\"\>data STAT = asgStat(Id name, EXP exp)\n          | ifStat(EXP exp,list[STAT] thenpart,\n                           list[STAT] elsepart) \n          | whileStat(EXP exp, list[STAT] body)\n          ;\n\</pre\>","","",[])