concept("IntroRewriteRules",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/IntroRewriteRules/IntroRewriteRules.concept|,[],[],{"Beginner"},{},"","","","",{}," Rewrite Rules\n \<br/\>\n\<br/\>\n\n A rewrite rule is a recipe on how to simplify values. \n Remember: (\<code\>\<i\>a\</i\>\</code\> + \<code\>\<i\>b\</i\>\</code\>)\<code\>\<i\>\</i\>\<sup\>2\</sup\>\</code\> = \<code\>\<i\>a\</i\>\<sup\>2\</sup\>\</code\> + 2\<code\>\<i\>ab\</i\>\</code\> + \<code\>\<i\>b\</i\>\<sup\>2\</sup\>\</code\>? \n A rewrite rule has a pattern as left-hand side (here: (\<code\>\<i\>a\</i\>\</code\> + \<code\>\<i\>b\</i\>\</code\>)\<code\>\<i\>\</i\>\<sup\>2\</sup\>\</code\> and a replacement as \n right-hand side (here: \<code\>\<i\>a\</i\>\<sup\>2\</sup\>\</code\> + 2\<code\>\<i\>ab\</i\>\</code\> + \<code\>\<i\>b\</i\>\<sup\>2\</sup\>\</code\>). \n Given a value and a set of rewrite rules the patterns are tried on every subpart of the value and replacements are made if a match is successful. This is repeated as long as some pattern matches.\n \<br/\>\n\<br/\>\n\n Rewrite rules are the only implicit control mechanism in the language and are used to maintain invariants \n during computations.\n Since rewrite rules are activated automatically, one may always assume that expressions are in simplified form.\n"," In a package for symbolic differentiation it is desirable to keep expressions in simplified form in order \n to avoid intermediate results like \<code\>sum(product(num(1), x), product(num(0), y))\</code\> that can be simplified to \<code\>x\</code\>. \n The following rules achieve this:\n \<pre class=\"listing\"\>rule simplify1 product(num(1), Expression e) =\> e;\nrule simplify2 product(Expression e, num(1)) =\> e;\nrule simplify3 product(num(0), Expression e) =\> num(0);\nrule simplify4 product(Expression e, num(0)) =\> num(0);\nrule simplify5 sum(num(0), Expression e)     =\> e;\nrule simplify6 sum(Expression e, num(0))     =\> e;\n\</pre\> Whenever a new value of type \<code\>Expression\</code\> is constructed during symbolic differentiation, these rules are \<i\>implicitly\</i\> applied \n to that expression and all its subexpressions and when a pattern at the left-hand side of a rule applies the matching subexpression is replaced by the right-hand side of the rule. This is repeated as long as any rule can be applied.\n",""," Rewrite rules are \<i\>Turing complete\</i\>, in other words any computable function can be defined using rewrite rules, \n including functions that do not terminate. This is a point of attention when using rewrite rules.\n",[])