concept("Function",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Declarations/Function/Function.concept|,[],[],{"Language","Beginner"},{"Tuple/Subscription","TypeParameters"},""," \<ol\>\<li\> \<code\>\<i\>Type\</i\> \<i\>Name\</i\>( \<i\>Type\</i\>\<sub\>1\</sub\> \<i\>Var\</i\>\<sub\>1\</sub\>, ..., \<i\>Type\</i\>\<sub\>n\</sub\> \<i\>Var\</i\>\<sub\>n\</sub\> ) \<i\>Statement\</i\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Type\</i\> \<i\>Name\</i\>( \<i\>Type\</i\>\<sub\>1\</sub\> \<i\>Var\</i\>\<sub\>1\</sub\>, ..., \<i\>Type\</i\>\<sub\>n\</sub\> \<i\>Var\</i\>\<sub\>n\</sub\> \<i\>Type\</i\>\<sub\>0\</sub\> \<i\>Name\</i\>\<sub\>0\</sub\>... ) \<i\>Statement\</i\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Type\</i\> \<i\>Name\</i\>( \<i\>Type\</i\>\<sub\>1\</sub\> \<i\>Var\</i\>\<sub\>1\</sub\>, ..., \<i\>Type\</i\>\<sub\>n\</sub\> \<i\>Var\</i\>\<sub\>n\</sub\> ) throws \<i\>Exception\</i\>\<sub\>1\</sub\>, \<i\>Exception\</i\>\<sub\>2\</sub\>, ... \<i\>Statement\</i\> \</code\>\</li\>\n\</ol\>","","",{"throws",",",")","("}," \<h2\> Variant 1 \</h2\>\n A function declaration introduces a new function with name \<code\>\<i\>Name\</i\>\</code\>, typed formal parameters \<code\>\<i\>Type\</i\>\<sub\>1\</sub\> \<i\>Var\</i\>\<sub\>1\</sub\>\</code\>, a return type \<code\>\<i\>Type\</i\>\</code\>\n and a \<code\>\<i\>Statement\</i\>\</code\> that forms the function body.\n The type of \<code\>\<i\>Statement\</i\>\</code\> should be equal to \<code\>\<i\>Type\</i\>\</code\>.\n \<br/\>\n\<br/\>\n\n The formal parameters may be used in \<code\>\<i\>Statement\</i\>\</code\> and get their value when function \<code\>\<i\>Name\</i\>\</code\> is invoked.\n  \<h2\> Variant 2 \</h2\>\n A function may have a variable list of arguments, this has as syntax variant 2 given above.\n \<br/\>\n\<br/\>\n\n The last parameter of a function may be followed by \<code\>...\</code\> and this has as effect that all remaining actual parameters\n that occur in a call to this function are collected as list value of the last formal parameter. \n Inside the function body, the type of this parameter will therefore be \<code\>list[\<i\>Type\</i\>\<sub\>0\</sub\>]\</code\>.\n  \<h2\> Variant 3 \</h2\>\n The exceptions that can be thrown by a function can be (optionally) declared as shown in syntax variant 3 above. \n  \<h2\> Parameterized types in function declaration \</h2\>\n The types that occur in function declarations may also contain \<a href=\"/show?concept=TypeParameters\"\>TypeParameters\</a\>.\n In this way functions can be defined for arbitrary types. The type variable is bound at the moment the function is called.\n"," \<pre class=\"screen\"\>\</pre\>\n  Declare a function\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>rel[int, int] invert(rel[int,int] R){\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;   return {&lt;Y, X&gt; | &lt;int X, int Y&gt; &lt;- R };\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;}\nrel[int, int] (rel[int, int]): rel[int, int] invert(rel[int, int]);\n\</pre\>\n  Call it\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>invert({&lt;1,10&gt;, &lt;2,20&gt;});\nrel[int, int]: {&lt;20,2&gt;,&lt;10,1&gt;}\n\</pre\> In the following example we illustrate the use of type vriables in function declarations.\n Declare an inversion function that is applicable to any binary relation:\n \<pre class=\"screen\"\>\<b\>rascal\>\</b\>rel[&amp;T2, &amp;T1] invert2(rel[&amp;T1,&amp;T2] R){  \n&gt;&gt;&gt;&gt;&gt;&gt;&gt;   return {&lt;Y, X&gt; | &lt;&amp;T1 X, &amp;T2 Y&gt; &lt;- R };\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;}\nrel[&amp;T2, &amp;T1] (rel[&amp;T1, &amp;T2]): rel[&amp;T2, &amp;T1] invert2(rel[&amp;T1, &amp;T2]);\n\</pre\>\n Now apply it to relations with different types:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>invert2({&lt;1,10&gt;, &lt;2,20&gt;});\nrel[int, int]: {&lt;20,2&gt;,&lt;10,1&gt;}\n\<b\>rascal\>\</b\>invert2({&lt;&quot;mon&quot;, 1&gt;, &lt;&quot;tue&quot;, 2&gt;});\nrel[int, str]: {&lt;1,&quot;mon&quot;&gt;,&lt;2,&quot;tue&quot;&gt;}\n\</pre\>\n  As another example declare a function that can be used to swap the elements of pairs of arbitrary types\n  (also see \<a href=\"/show?concept=Tuple/Subscription\"\>Tuple/Subscription\</a\>):\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>tuple[&amp;T2, &amp;T1] swap(tuple[&amp;T1, &amp;T2] TP) { return &lt;TP[1], TP[0]&gt;;}\ntuple[&amp;T2,&amp;T1] (tuple[&amp;T1,&amp;T2]): tuple[&amp;T2,&amp;T1] swap(tuple[&amp;T1,&amp;T2]);\n\<b\>rascal\>\</b\>swap(&lt;1, 2&gt;);\ntuple[int,int]: &lt;2,1&gt;\n\<b\>rascal\>\</b\>swap(&lt;&quot;wed&quot;, 3&gt;);\ntuple[int,str]: &lt;3,&quot;wed&quot;&gt;\n\</pre\>","","",[])