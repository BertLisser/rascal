concept("Rascal",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Rascal.concept|,[],["EASY","Concepts","Examples","Declarations","Expressions","Statements","Libraries"],{"Library","Example","Language","Beginner"},{"EASY"},"","","","",{}," \<i\>Meta-programs\</i\> are programs that analyze, transform or generate other programs. Ordinary programs work on data; meta-programs work on programs. The range of programs to which meta-programming can be applied is large: from programs in standard languages like C and Java to domain-specific languages for describing high-level system models or applications in specialized areas like gaming or finance. In some cases, even test results or performance data are used as input for meta-programs.\n \<br/\>\n\<br/\>\n\n Rascal is a new language for \<i\>meta-programming\</i\>, this is the activity of writing meta-programs.\n It is intended for reading, analyzing, and transforming other programs. \n"," Typical applications of Rascal are:\n \<ul\>\<li\> Refactoring of Java source code.\</li\>\n\<li\> Searching for buffer overflows in C code.\</li\>\n\<li\> Analyzing the version history of a large software project.\</li\>\n\<li\> Implementing a \<i\>domain-specific language\</i\> (DSL) for describing business processes.\</li\>\n\</ul\> All these cases involve a form of meta-programming: software programs (in a wide sense) are the objects-of-interest that are being analyzed, transformed or generated. The Rascal language is designed for meta-programming following the \<a href=\"/show?concept=EASY\"\>EASY\</a\> paradigm. It can be applied in domains ranging from compiler construction and implementing domain-specific languages to constraint solving and software renovation.\n \<br/\>\n\<br/\>\n\n Since representation of information is central to the approach, Rascal provides a rich set of built-in data types. To support extraction and analysis, parsing and advanced pattern matching are provided. High-level control structures make analysis and synthesis of complex datastructures simple.\n"," \<ul\>\<li\> \<b\>Familiar syntax\</b\> in a \<i\>what-you-see is-what-you-get\</i\> style is used even for sophisticated concepts     and this makes the language easy to learn and easy to use.\n\</li\>\n\<li\> \<b\>Sophisticated built-in data types\</b\> provide standard solutions for many meta-programming problems.\</li\>\n\<li\> \<b\>Safety\</b\> is achieved by finding most errors before the program is executed and by making common errors    like missing initializations or invalid pointers impossible. \n\</li\>\n\<li\> \<b\>Local type inference\</b\> makes local variable declarations redundant.\</li\>\n\<li\> \<b\>Pattern matching\</b\> can be used to analyze all complex datastructures.\</li\>\n\<li\> \<b\>Syntax definitions\</b\> make it possible to define new and existing languages and to write tools for them.\</li\>\n\<li\> \<b\>Visiting\</b\> makes it easy to traverse datastructures and to extract information from them or to synthesize results.\</li\>\n\<li\> \<b\>Templates\</b\> enable easy code generation.\</li\>\n\<li\> \<b\>Functions as values\</b\> permit programming styles with high re-use.\</li\>\n\<li\> \<b\>Generic types\</b\> allow writing functions that are applicable for many different types.\</li\>\n\<li\> \<b\>Eclipse integration\</b\> makes Rascal programming a breeze. All familiar tools are at your fingertips.\</li\>\n\</ul\>"," \<ul\>\<li\> Rascal programs are not yet highly optimized so execution maybe slow for some programs.\</li\>\n\<li\> At the time of writing, this checking is done during execution, but we are working on this.\</li\>\n\</ul\>",[])