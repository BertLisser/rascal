concept("Abstract",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Patterns/Abstract/Abstract.concept|,[],[],{},{"Real","Integer","DateTime","Number","Boolean","Location","String"},"","","","",{}," An abstract pattern is recursively defined and may contain the following elements:\n  \<ul\>\<li\> Literal of one of the basic types \<a href=\"/show?concept=Boolean\"\>Boolean\</a\>, \<a href=\"/show?concept=Integer\"\>Integer\</a\>, \<a href=\"/show?concept=Real\"\>Real\</a\>, \<a href=\"/show?concept=Number\"\>Number\</a\>, \<a href=\"/show?concept=String\"\>String\</a\>, \<a href=\"/show?concept=Location\"\>Location\</a\>, or \<a href=\"/show?concept=DateTime\"\>DateTime\</a\>.  A literal pattern matches with a value that is identical to the literal.\n\</li\>\n\<li\> A \<i\>variable declaration pattern\</i\> \<pre class=\"listing\"\>\<i\>Type\</i\> \<i\>Var\</i\>\n\</pre\> A variable declaration introduces a new variable \<code\>\<i\>Var\</i\>\</code\> that matches any value of the given type \<code\>\<i\>Type\</i\>\</code\>.\n That value is assigned to \<code\>\<i\>Var\</i\>\</code\> when the whole match succeeds.\n\</li\>\n\<li\> A \<i\>multi-variable pattern\</i\> \<pre class=\"listing\"\>\<i\>Var\</i\>*\n\</pre\> A multi-variable is an abbreviation for a variable declaration pattern.\n  It can occur in a list pattern or set pattern and can match zero or more list or set elements.\n\</li\>\n\<li\> A \<i\>variable pattern\</i\> \<pre class=\"listing\"\>Var\n\</pre\> A variable pattern can act in two roles:\n \<ul\>\<li\>If \<code\>\<i\>Var\</i\>\</code\> has already a defined value then it matches with that value.\</li\>\n\<li\> If \<code\>\<i\>Var\</i\>\</code\> has not been defined before (or it has been declared but not initialized) then it matches any value.      That value is assigned to \<code\>\<i\>Var\</i\>\</code\>. \<warning\>Explain scope.\</warning\>\n\</li\>\n\</ul\>\</li\>\n\<li\> A \<i\>list pattern\</i\> \<pre class=\"listing\"\>[ \<i\>Pat\</i\>\<sub\>1\</sub\>, \<i\>Pat\</i\>\<sub\>2\</sub\>, ..., \<i\>Pat\</i\>\<sub\>n\</sub\> ]\n\</pre\> A list pattern matches a list value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> match the elements of that list in order. \n Two special cases exist when one of the patterns \<code\>\<i\>Pat\</i\>\<sub\>i\</sub\>\</code\> is\n \<ul\>\<li\> a variable declaration pattern with a list type that is identical to the type of the list that is being matched.\</li\>\n\<li\> a variable pattern, where the variable has been declared, but not initialized, outside the pattern with a list type that is identical to the type of the list that is being matched.\<br/\>\n\<br/\>\n In both cases list matching is applied and the variable can match an arbitrary number of elements of the subject list.\n\</li\>\n\</ul\>\</li\>\n\<li\> A \<i\>set pattern\</i\> \<pre class=\"listing\"\>{ \<i\>Pat\</i\>\<sub\>1\</sub\>, \<i\>Pat\</i\>\<sub\>2\</sub\>, ..., \<i\>Pat\</i\>\<sub\>n\</sub\> }\n\</pre\> A set pattern matches a set value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> match the elements of that set in any order. Completely analogous to list patterns, there are two special cases when one of the patterns \<code\>\<i\>Pat\</i\>\<sub\>i\</sub\>\</code\> is\n \<ul\>\<li\> a variable declaration pattern with a set type that is identical to the type of the set that is being matched.\</li\>\n\<li\> a variable pattern, where the variable has been declared, but not initialized, outside the pattern with a set type that is identical to the type of the set that is being matched.\<br/\>\n\<br/\>\n In both cases set matching is applied and the variable can match an arbitrary number (in arbitrary order!) of elements of the subject set.\n\</li\>\n\</ul\>\</li\>\n\<li\> A \<i\>tuple pattern\</i\> \<pre class=\"listing\"\>&lt; \<i\>Pat\</i\>\<sub\>1\</sub\>, \<i\>Pat\</i\>\<sub\>2\</sub\>, ..., \<i\>Pat\</i\>\<sub\>n\</sub\> \>\n\</pre\> A tuple pattern matches a tuple value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\>  match the elements of that tuple in order.\n\</li\>\n\<li\> A \<i\>node pattern\</i\> \<pre class=\"listing\"\>\<i\>Name\</i\> ( \<i\>Pat\</i\>\<sub\>1\</sub\>, \<i\>Pat\</i\>\<sub\>2\</sub\>, ..., \<i\>Pat\</i\>\<sub\>n\</sub\> )\n\</pre\> A node pattern matches a node value or a datatype value, provided that \<code\>\<i\>Name\</i\>\</code\> matches with the constructor symbol of that value \n and \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\>  match the children of that value in order.\n\</li\>\n\<li\> A \<i\>descendant pattern\</i\> \<pre class=\"listing\"\>/ \<i\>Pat\</i\>\n\</pre\> performs a deep match of the pattern \<code\>\<i\>Pat\</i\>\</code\>. In other words, it matches when any element of the subject at any depth matches \<code\>\<i\>Pat\</i\>\</code\>\n  and is used to match, for instance, tree nodes at an arbitrary distance from the root.\n\</li\>\n\<li\> A \<i\>labelled pattern\</i\> \<pre class=\"listing\"\>\<i\>Var\</i\> : \<i\>Pat\</i\>\n\</pre\> A labelled pattern matches the same values as \<code\>\<i\>Pat\</i\>\</code\>, but has as side-effect that the matched value is assigned to \<code\>\<i\>Var\</i\>\</code\>.\n\</li\>\n\<li\> A \<i\>typed, labelled, pattern\</i\> \<pre class=\"listing\"\>\<i\>Type\</i\> \<i\>Var\</i\> : \<i\>Pat\</i\>\n\</pre\> A typed, labelled, pattern matches when the subject value has type \<code\>\<i\>Type\</i\>\</code\> and \<code\>\<i\>Pat\</i\>\</code\> matches. The matched value is assigned to \<code\>\<i\>Var\</i\>\</code\>.\n\</li\>\n\<li\> A \<i\>type constrained pattern\</i\> \<pre class=\"listing\"\>[\<i\>Type\</i\>] \<i\>Pat\</i\>\n\</pre\> matches provided that the subject has type \<code\>\<i\>Type\</i\>\</code\> and \<code\>\<i\>Pat\</i\>\</code\> matches.\n\</li\>\n\</ul\>","",""," Map patterns are not yet supported.\n",[])