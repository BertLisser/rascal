Name: StaticTyping

Synopsis: Static type checking.

Syntax:

Types:

Function:

Details:

Description:
![Type Lattice](type-lattice.png|right|400px)

Rascal is based on static typing, this means that as many errors and inconsistencies as possible are spotted before the program is executed. The types are ordered in a so-called _type lattice_ shown in the figure.

The arrows describe a _subtype-of_ relation between types. The type `void` is the _smallest_ type and 
is included in all other types and the type `value` is the _largest_ type that includes all other types. 
We also see that `rel` is a subtype of `set` and that each ADT is a subtype of `node`. 
A special role is played by the datatype <tt>Tree</tt> that is the generic type of syntax trees. 
Syntax trees for specific languages are all subtypes of `Tree`. As a result, syntax trees can be addressed at two levels: 
* in a generic fashion as `Tree` and,
* in a specific fashion as a more precisely typed syntax tree. 
Finally, each `alias` is structurally equivalent to one or more specific other types.


Rascal does not provide an explicit casting mechanism, but pattern matching can play that role.

Examples:

Some example can illustrate the above.
<screen errors>
int I = 3;
// Since I is declared as type `int`, we cannot assign a `real` value to it:
I = 3.5;
</screen>

<screen>
num N = 3;
// Since N is declared as type `num`, we can assign both `int` and `real` values to it:
N = 3.5;
</screen>

Since all types are a subtype of type `value`, one can assign values of any type to a variable declared as `value`:
<screen>
value V = 3;
V = "abc";
V = false;
// We can use pattern matching to classify the actual type of a value:
str classify(value V){
  switch(V){
    case str S: return "A string";
    case bool B: return "A Boolean";
    default: return "Another type"; 
  }
}
classify(V);
V = 3.5;
classify(V);
</screen>

In addition to these standard examples, it is interesting that all [AlgebraicDataType]s are subtypes of type `node`.
Let's introduce a simple `Color` data type:
<screen>
data Color = red(int level) | blue(int level);
// Unsurprisingly, we have:
Color C = red(3);
// Due to subtyping, we can also have:
node ND = red(3);
</screen>

One example of the actual application of subtypes can be found in [Recipes:CountConstructors].

Benefits:

Pitfalls:

Questions:

