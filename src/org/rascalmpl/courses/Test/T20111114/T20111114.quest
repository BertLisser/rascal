[choiceQuestion("Test/T20111114","1","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All keys have the same type."),good("All keys should have the same type and all values should have the same type. The type of keys and values may be different."),bad("All keys should have the same type and all values should have the same type. The type of keys and values should be the same."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are sorted.")]),choiceQuestion("Test/T20111114","2","  In a tuple:\n",[good("All elements may have different types."),good("The number of elements is fixed."),good("The order of the elements is relevant."),bad("All elements should have the same type."),bad("The number of elements is not fixed."),bad("The order of the elements is not relevant.")]),choiceQuestion("Test/T20111114","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates."),bad("Has a fixed length.")]),choiceQuestion("Test/T20111114","4","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The type of the element that was first added to the set."),bad("The average of the type of the elements with the smallest and the largests type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111114","5","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111114","6",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111114","7",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20),1,5),"")),tvQuestion("Test/T20111114","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value(),1,5),"")),tvQuestion("Test/T20111114","9",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111114","10",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111114","11",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[str] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","12",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"n\") == [\"An\", \"honest\", \"man\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","13",valueOfExpr(),details(" Return the set of largest words.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Steve\", \"Jobs\", \":\", \"And\", \"one\", \"more\", \"thing\"];\npublic list[str] largest(list[str] text){\n  mx = ( 0 | max(it, size(s)) | s \<- text );\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","largest(text) == [\"Quote\", \"Steve\", \"thing\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","14",valueOfExpr(),details(" Complete this function that returns the set of keys with the smallest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] lowest(map[str,int] inv){\n    m = ","; // Determine the minimal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","lowest(inventory) == {\"apple\", \"lemon\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","15",valueOfExpr(),details(" Complete this function that tests that a list of words consists of two identical sublists:\n",[],"import List;\npublic bool isReplicated(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isReplicated([\"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","16",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all red nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipRedChildren(ColoredTree t){\n  return visit(t){\n     case red(l,r) =\> ","\n  };\n}\n","flipRedChildren(rb) == red( black(leaf(3), leaf(4)), black(leaf(1), red(leaf(3),leaf(2))));","",true,false,[],[],void(),""))]