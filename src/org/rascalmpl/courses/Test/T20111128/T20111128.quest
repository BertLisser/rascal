[choiceQuestion("Test/T20111128","1","  A list:\n",[good("Has elements that are ordered."),good("Can contain zero or more elements."),good("Can contain duplicate elements."),bad("Has elements that are unordered."),bad("Can contain one or more elements."),bad("Can not contain duplicate elements.")]),choiceQuestion("Test/T20111128","2","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All (key, value) pairs are unordered."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are ordered."),bad("All values are ordered."),bad("All (key, value) pairs are ordered.")]),choiceQuestion("Test/T20111128","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates.")]),choiceQuestion("Test/T20111128","4","  The following statement about subtypes is correct:\n",[good("`int` is a subtype of `num`."),good("`real` is a subtype of `number`."),good("`int` is a subtype of `real`."),good("`num` is a subtype of `value`."),good("An Algebraic Data Type (defined using `data`) is a subtype of `node`."),good("A relation is a subtype of set."),bad("`bool` is a subtype of `int`."),bad("`num` is a subtype of `real`."),bad("`value` is a subtype of `void`.")]),choiceQuestion("Test/T20111128","5","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The average of the type of the elements with the smallest and the largest type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111128","6","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111128","7",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111128","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20),1,5),"")),tvQuestion("Test/T20111128","9",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value(),1,5),"")),tvQuestion("Test/T20111128","10",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111128","11",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]),1,5)>],[],void(),"")),tvQuestion("Test/T20111128","12",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[int] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","13",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"s\") == [\"honest\", \"is\", \"always\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","14",valueOfExpr(),details(" Return the list of words with a length smaller than or equal to \<code\>n\</code\>.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Mahatma\", \"Gandhi:\", \n\"Freedom\", \"is\", \"not\", \"worth\", \"having\", \"if\", \"it\", \"does\", \"not\", \n\"include\", \"the\", \"freedom\", \"to\", \"make\", \"mistakes\"];\n\npublic list[str] smallerOrEq(list[str] text, int n){\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","smallerOrEq(text, 3) == [\"is\", \"not\", \"if\", \"it\", \"not\", \"the\", \"to\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","15",valueOfExpr(),details(" Complete this function that returns the set of keys with the largest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] largest(map[str,int] inv){\n    m = ","; // Determine the maximal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","largest(inventory) == {\"banana\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","16",valueOfExpr(),details(" Complete this function that tests that a list of words consists of three identical sublists:\n",[],"import List;\npublic bool isTriple(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isTriple([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","17",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all black nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipBlackChildren(ColoredTree t){\n  return visit(t){\n     case black(l,r) =\> ","\n  };\n}\n","flipBlackChildren(rb) ==  red(black(red(leaf(2),leaf(3)), leaf(1)), black(leaf(4), leaf(3)));","",true,false,[],[],void(),""))]